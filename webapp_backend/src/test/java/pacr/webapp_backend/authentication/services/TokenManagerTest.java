package pacr.webapp_backend.authentication.services;

import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.SignatureException;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

import javax.crypto.spec.SecretKeySpec;
import java.util.Date;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class TokenManagerTest {

    private static final byte[] SECRET = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
    private static final byte[] EMPTY_SECRET = {};
    private static final String ISSUER = "PACR-Backend";
    private static final String FOREIGN_ISSUER = "foreign";
    private static final String AUDIENCE = "admin";
    private static final String FALSE_TOKEN = "false";

    private TokenManager tokenManager;
    private IAuthenticationAccess authenticationAccessMock;

    public TokenManagerTest() {
        this.authenticationAccessMock = Mockito.mock(IAuthenticationAccess.class);
        this.tokenManager = new TokenManager(authenticationAccessMock);
    }

    /**
     * Tests whether the token manager accepts a token that was generated by itself.
     */
    @Test
    void generateToken_shouldAccept() {
        when(authenticationAccessMock.getSecret()).thenReturn(SECRET);

        String token = tokenManager.generateToken();

        assertTrue(tokenManager.authenticate(token));
    }

    /**
     * Tests whether generateToken generates a new secret if it is empty and whether the given token can be accepted.
     */
    @Test
    void generateToken_noSecret_shouldGenerateNewSecret() {
        when(authenticationAccessMock.getSecret()).thenReturn(EMPTY_SECRET);

        String token = tokenManager.generateToken();

        ArgumentCaptor<byte[]> secretCaptor = ArgumentCaptor.forClass(byte[].class);
        verify(authenticationAccessMock).setSecret(secretCaptor.capture());

        when(authenticationAccessMock.getSecret()).thenReturn(secretCaptor.getValue());

        assertTrue(tokenManager.authenticate(token));
    }

    /**
     * Tests whether authenticate returns false if you give it a foreign key.
     */
    @Test
    void authenticate_wrongSignature_shouldReturnFalse() {
        when(authenticationAccessMock.getSecret()).thenReturn(SECRET);

        byte[] foreignSecret = new byte[SECRET.length];
        foreignSecret[0] = 127;
        System.arraycopy(SECRET, 1, foreignSecret, 1, foreignSecret.length - 1);

        String foreignToken = generateComparisonToken(foreignSecret, ISSUER, AUDIENCE);

        assertFalse(tokenManager.authenticate(foreignToken));
    }

    /**
     * Tests whether authenticate returns false if the issuer does not match.
     */
    @Test
    void authenticate_wrongIssuer_shouldReturnFalse() {
        when(authenticationAccessMock.getSecret()).thenReturn(SECRET);

        String foreignToken = generateComparisonToken(SECRET, FOREIGN_ISSUER, AUDIENCE);

        assertFalse(tokenManager.authenticate(foreignToken));
    }

    @Test
    void authenticate_noSecret_shouldReturnFalse() {
        when(authenticationAccessMock.getSecret()).thenReturn(EMPTY_SECRET);

        String token = tokenManager.generateToken();
        assertFalse(tokenManager.authenticate(token));
    }

    private String generateComparisonToken(byte[] secret, String issuer, String audience) {
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

        JwtBuilder builder = Jwts.builder()
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setIssuer(issuer)
                .setAudience(audience)
                .signWith(new SecretKeySpec(secret, signatureAlgorithm.getJcaName()), signatureAlgorithm);

        return builder.compact();
    }
}
